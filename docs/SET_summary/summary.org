#+TITLE: Time Delay Estimation in Gravitationally Lensed Photon Stream Pairs
#+AUTHOR: \Large{Micha{\l} Staniaszek} \\\small{Supervisor: Peter Ti{\v{n}}o}
#+EMAIL:     mxs968@cs.bham.ac.uk
#+DATE:      \today
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE:  en
#+OPTIONS:   H:3 num:t toc:nil \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:   
#+LINK_HOME: 
#+XSLT:
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [a4paper,11pt]
#+LATEX_HEADER: \usepackage{fontspec}
#+LATEX_HEADER: \usepackage[titletoc,page,title]{appendix}
#+LaTeX_HEADER: \usepackage{biblatex}
#+LaTeX_HEADER: \usepackage{metalogo}
#+LaTeX_HEADER: \usepackage{graphicx}
#+LaTeX_HEADER: \usepackage{moreverb}
#+LaTeX_HEADER: \usepackage{fancyvrb}
#+LaTeX_HEADER: \usepackage{fullpage}
#+LaTeX_HEADER: \usepackage{setspace}
#+LaTeX_HEADER: \usepackage{subfig}
#+LaTeX_HEADER: \usepackage{algorithm}
#+LaTeX_HEADER: \usepackage{algorithmic}
#+LaTeX_HEADER: \usepackage[scientific-notation=true]{siunitx}
#+LaTeX_HEADER: \usepackage{float}
#+LaTeX_HEADER: \let\iint\relax % otherwise errors are thrown by amsmath. Defined in latexsym
#+LaTeX_HEADER: \let\iiint\relax
#+LaTeX_HEADER: \usepackage{amsmath}
#+LaTeX_HEADER: \usepackage{hyperref}
#+LaTeX_HEADER: \usepackage{tikz}
#+LaTeX_HEADER: \usetikzlibrary{positioning}
#+LaTeX_HEADER: \bibliography{fyp}
#+LATEX_HEADER: \defaultfontfeatures{Mapping=tex-text}
#+LATEX_HEADER: \setromanfont[Ligatures={Common},Numbers={Lining}]{Linux Libertine}

#+BEGIN_abstract
this is the abstract
#+END_abstract

* Introduction
 - explain the project in layman's terms
* Background
  - Ideas behind the project
  - what it's useful for
  - what gravitational lensing and time delay are
* Photon Stream Simulation
In the early stages of the project, we developed a subsystem which could be used
to generate simulated photon stream data to use for the development and testing
of the rest of the project. The only property of the photons which we are
interested in is their arrival time at our capture device, so the simulator
should produce some vector $\Phi=\left[\phi_0,\dots,\phi_N\right], \phi_n \in
\mathbb{R}$, where $\phi_n$ is the arrival time of the $n\text{th}$ photon. In
order to generate arrival times, we represent the source as some random variable
$X$, which defines the average number of photons per unit time that arrive at
the capture device.

The behaviour of $X$ is modelled as a non-homogeneous Poisson process (NHPP)
with continuous rate function $\lambda(t)$, where $t$ is some point in time. The
rate function can be specified either by providing an expression which is a
function of $t$, or by sampling from a randomly generated function. Random
functions are constructed by uniformly distributing $M$ Gaussians across the
interval $\left[t_0,T\right]$ in which arrival times are to be generated. Each
Gaussian $g_i$ is defined by its mean \mu_i, its width \sigma_i, and its
weight $w_i$, which determines its height. The means of successive Gaussians are
separated by some distance $\Delta t$, such that $\mu_{m+1}=\mu_m + \Delta
t,\text{ where } \mu_0=0$. Greater variation in the functions is introduced by
sampling the weights $w_i$ from a uniform distribution $U(-1,1)$ and scaling
them by some multiplier. A weighted sum of Gaussians
\begin{align}
   f(t) = \sum_{i=0}^M w_i\cdot e^{-(t-\mu_i)^2/2\sigma_i^2}
\end{align}
is used to compute the value of the randomly generated function $f$ at some
point $t$ by summing the values of all Gaussians at that point.

Thus, the simulator creates a very simple model of a source object from which to
generate photon arrival times.

Having defined or constructed $\lambda(t)$, we generate photon arrival times by
thinning arrival times generated with inverse transform sampling.

\begin{comment}
  \begin{algorithm}[H]
    \begin{algorithmic}[1]
      \REQUIRE $\lambda\geq \lambda(t), 0 \leq t \leq T$
      \STATE $\Phi=\emptyset$, $t=0$, $T=\text{interval length}$
      \WHILE{$t<T$}
      \STATE Generate $U_1\sim U(0,1)$
      \STATE $\phi_n=t-\frac{1}{\lambda}\ln(U_1)$
      \STATE Generate $U_2\sim U(0,1)$, independent of $U_1$
      \IF{$U_2\leq\frac{\lambda(t)}{\lambda}$}
      \STATE $\Phi \leftarrow \phi_n$
      \ENDIF
      \ENDWHILE
      \RETURN $\Phi$
    \end{algorithmic}
    \caption{Simulating T Time Units of a NHPP by Thinning}
    \label{alg:seq}
  \end{algorithm}
\end{comment}

* Function Estimation
  - Basic explanation of the IWLS estimator
  - slightly more in-depth stuff for the development of our estimators
* Time Delay Estimation
** PDF Method
** Area Method
* Experimental Results
 - general explanation of the experiments performed
 - how was model selection done
 - what sort of data were experiments performed on
* System
 - very brief explanation of the system features
* Conclusion
 - some suggestions for extensions
