#+TITLE: Time Delay Estimation in Gravitationally Lensed Photon Stream Pairs
#+AUTHOR: \Large{Micha{\l} Staniaszek} \\\small{Supervisor: Peter Ti{\v{n}}o}
#+EMAIL:     mxs968@cs.bham.ac.uk
#+DATE:      \today
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE:  en
#+OPTIONS:   H:3 num:t toc:nil \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:   
#+LINK_HOME: 
#+XSLT:
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [a4paper,11pt]
#+LATEX_HEADER: \usepackage{fontspec}
#+LATEX_HEADER: \usepackage[titletoc,page,title]{appendix}
#+LaTeX_HEADER: \usepackage{biblatex}
#+LaTeX_HEADER: \usepackage{metalogo}
#+LaTeX_HEADER: \usepackage{graphicx}
#+LaTeX_HEADER: \usepackage{moreverb}
#+LaTeX_HEADER: \usepackage{fancyvrb}
#+LaTeX_HEADER: \usepackage{fullpage}
#+LaTeX_HEADER: \usepackage{setspace}
#+LaTeX_HEADER: \usepackage{subfig}
#+LaTeX_HEADER: \usepackage{algorithm}
#+LaTeX_HEADER: \usepackage{algorithmic}
#+LaTeX_HEADER: \usepackage[scientific-notation=true]{siunitx}
#+LaTeX_HEADER: \usepackage{float}
#+LaTeX_HEADER: \let\iint\relax % otherwise errors are thrown by amsmath. Defined in latexsym
#+LaTeX_HEADER: \let\iiint\relax
#+LaTeX_HEADER: \usepackage{amsmath}
#+LaTeX_HEADER: \usepackage{hyperref}
#+LaTeX_HEADER: \usepackage{tikz}
#+LaTeX_HEADER: \usetikzlibrary{positioning}
#+LaTeX_HEADER: \bibliography{fyp}
#+LATEX_HEADER: \defaultfontfeatures{Mapping=tex-text}
#+LATEX_HEADER: \setromanfont[Ligatures={Common},Numbers={Lining}]{Linux Libertine}

#+BEGIN_abstract
this is the abstract
#+END_abstract

* Introduction
 - explain the project in layman's terms
* Background
  - Ideas behind the project
  - what it's useful for
  - what gravitational lensing and time delay are
* Photon Stream Simulation
In the early stages of the project, we developed a subsystem which could be used
to generate simulated photon stream data to use for the development and testing
of the rest of the project. The only property of the photons which we are
interested in is their arrival time at our capture device, so the simulator
should produce some vector $\Phi=\left[\phi_0,\dots,\phi_N\right], \phi_n \in
\mathbb{R}$, where $\phi_n$ is the arrival time of the $n\text{th}$ photon. In
order to generate arrival times, we represent the source as some random variable
$X$, which defines the average number of photons per unit time that arrive at
the capture device. The behaviour of $X$ is modelled as a non-homogeneous
Poisson process (NHPP) with continuous rate function $\lambda(t)$. The rate
function can be specified either by providing an expression which is a function
of $t$, or by sampling from a randomly generated function. Random functions are
constructed by uniformly distributing $M$ Gaussians across the interval
$\left[t_0,T\right]$ in which arrival times are to be generated. Thus, the
simulator creates a very simple model of a source object form which to generate
photon arrival times.

\begin{comment}
  \begin{algorithm}[H]
    \begin{algorithmic}[1]
      \REQUIRE $\lambda\geq \lambda(t), 0 \leq t \leq T$
      \STATE $\Phi=\emptyset$, $t=0$, $T=\text{interval length}$
      \WHILE{$t<T$}
      \STATE Generate $U_1\sim U(0,1)$
      \STATE $\phi_n=t-\frac{1}{\lambda}\ln(U_1)$
      \STATE Generate $U_2\sim U(0,1)$, independent of $U_1$
      \IF{$U_2\leq\frac{\lambda(t)}{\lambda}$}
      \STATE $\Phi \leftarrow \phi_n$
      \ENDIF
      \ENDWHILE
      \RETURN $\Phi$
    \end{algorithmic}
    \caption{Simulating T Time Units of a NHPP by Thinning}
    \label{alg:seq}
  \end{algorithm}
\end{comment}
The function $\lambda(t)$ is the characteristic function of the object
from which the photon stream propagates, and defines the arrival rate of photons
at some time $t$. Given that the

* Function Estimation
  - Basic explanation of the IWLS estimator
  - slightly more in-depth stuff for the development of our estimators
* Time Delay Estimation
** PDF Method
** Area Method
* Experimental Results
 - general explanation of the experiments performed
 - how was model selection done
 - what sort of data were experiments performed on
* System
 - very brief explanation of the system features
* Conclusion
 - some suggestions for extensions
